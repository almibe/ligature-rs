// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

import Gaze from "./gaze"
import List from "list"
import Option from "option"

/**
 * Create a Nibbler that take a single literal value.
 * 
 * @param t: The literal to take.
 * 
 * @returns A Nibbler that takes a single literal.
 */
export let take = (t) => (gaze) => {
    if (Gaze.next(gaze) == Some(t)) {
        Some(t)
    } else {
        None
    }
}

/**
 * Create a Nibbler that accepts input based on a function that recieves the current token
 * and returns a bool.
 * 
 * @param predicate: The function used to decide if a token matches.
 * 
 * @returns A Nibbler that consumes one item as long as the predicate passes.
 */
export let takeCond = predicate => (gaze) => {
    let next = Gaze.peek(gaze)
    match (next) {
        Some(value) when predicate(value) => {
            Gaze.next(gaze)
            Some(value)
        },
        _ => None
    }
}

/**
 * Create a Nibbler that accepts input based on a function that recieves the current token
 * and returns a bool.
 * 
 * @param predicate: The function used to decide if a token matches.
 * 
 * @returns A Nibbler that consumes input as long as the predicate passes.
 */
export let takeWhile = predicate => (gaze) => {
    let mut cont = true
    let mut results = []
    while (cont) {
        let next = Gaze.peek(gaze)
        match (next) {
            Some(value) when predicate(value) => {
                Gaze.next(gaze)
                results = List.append(results, [value])
            },
            _ => cont = false
        }
    }
    if (List.length(results) == 0) {
        None
    } else {
        Some(results)
    }
}

/**
 * Create a Nibbler that accepts input based on a function that recieves the current token 
 * with index starting at 0 and returns a bool.
 * 
 * @param predicate: The function used to decide if a token matches.
 * 
 * @returns A Nibbler that consumes input as long as the predicate passes.
 */
export let takeWhileIndex = predicate => (gaze) => {
    let mut index = 0
    let mut cont = true
    let mut results = []
    while (cont) {
        let next = Gaze.peek(gaze)
        match (next) {
            Some(value) when predicate(value, index) => {
                Gaze.next(gaze)
                results = List.append(results, [value])
                index += 1
            },
            _ => cont = false
        }
    }
    if (List.length(results) == 0) {
        None
    } else {
        Some(results)
    }
}

/**
 * Create a Nibbler that accepts a start
 * 
 * @param start: The starting token.
 * @param content: The Nibbler used to decide the matched content.
 * @param end: The ending token.
 * 
 * @returns A Nibbler that consumes a starting and ending token and returns the content that matches in between.
 */
export let between = (start, content, end) => (gaze) => {
    if (Gaze.next(gaze) == Some(start)) {
        match (Gaze.attempt(content, gaze)) {
            Some(result) => {
                if (Gaze.next(gaze) == Some(end)) {
                    Some(result)
                } else {
                    None
                }
            },
            None => None
        }
    } else {
        None
    }
}

export let repeat = (nibbler) => (gaze) => {
    let mut cont = true
    let mut results = []
    while (cont) {
        match (Gaze.attempt(nibbler, gaze)) {
            Some(result) => {
                results = List.append(results, [result])
            },
            None => cont = false
        }
    }
    if (results == []) {
        None
    } else {
        Some(results)
    }
}

/**
 * Create a Nibbler that accepts a List of Nibblers and only succeeds if all of the
 * passed in Nibblers succeed in order.
 * 
 * @param nibblers: A List of nibblers.
 * 
 * @returns A List of all of the results from each Nibbler internally grouped in Lists.
 */
export let takeAll = nibblers => gaze => {
    let mut results = []
    let mut nibblerIndex = 0
    while (nibblerIndex >= 0 && nibblerIndex < List.length(nibblers)) {
        let nibbler = Option.unwrap(List.nth(nibblerIndex, nibblers))
        match (Gaze.attempt(nibbler, gaze)) {
            Some(result) => {
                results = List.append(results, [result])
                nibblerIndex += 1
            },
            None => {
                nibblerIndex = -1
            }
        }
    }
    if (results == [] || nibblerIndex == -1) {
        None
    } else {
        Some(results)
    }
}

/**
 * Create a Nibbler that accepts a List of Nibblers and matches on the first that succeeds.
 * If all fail the created Nibbler will fail as well.
 * 
 * @param nibblers: A list of Nibblers to check.
 * 
 * @returns The newly created Nibbler.
 */
export let takeFirst = nibblers => gaze => {
    let mut result = None
    let mut nibblerIndex = 0
    while (nibblerIndex >= 0 && nibblerIndex < List.length(nibblers)) {
        let nibbler = Option.unwrap(List.nth(nibblerIndex, nibblers))
        match (Gaze.attempt(nibbler, gaze)) {
            Some(res) => {
                result = Some(res)
                nibblerIndex = -1
            },
            None => {
                nibblerIndex += 1
            }
        }
    }
    result
}
