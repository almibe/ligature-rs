// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

import Gaze from "./gaze"
import List from "list"
import Option from "option"
import String from "string"
import Array from "array"

/**
 * Create a Nibbler that take a single literal value.
 * 
 * @param t: The literal to take.
 * 
 * @returns A Nibbler that takes a single literal.
 */
export let take = t => gaze => {
    if (Gaze.next(gaze) == Some(t)) {
        Some(t)
    } else {
        None
    }
}

/**
 * Create a Nibbler that takes a list of tokens.
 * 
 * @param list: The list of tokens to take.
 * 
 * @returns The newly created Nibbler.
 */
export let takeList = list => gaze => {
    let length = List.length(list)
    let mut index = 0
    let mut cont = true
    while (!Gaze.isComplete(gaze) && cont && index < length) {
        let next = Gaze.next(gaze)
        match (next) {
            Some(value) => {
                if (value == Option.unwrap(List.nth(index, list))) {
                    index += 1
                } else {
                    cont = false
                }
            },
            None => {
                cont = false
            }
        }
    }
    if (cont && index == length) {
        Some(list)
    } else {
        None
    }
}

/**
 * Create a Nibbler that takes a String when working with a Gaze<Char>.
 * This is just a helper function that relies on takeList.
 * 
 * @param string: The String to match.
 * 
 * @returns The newly created Nibbler.
 */
export let takeString = string => {
    takeList(Array.toList(String.explode(string)))
}

/**
 * Create a Nibbler that accepts input based on a function that recieves the current token
 * and returns a bool.
 * 
 * @param predicate: The function used to decide if a token matches.
 * 
 * @returns A Nibbler that consumes one item as long as the predicate passes.
 */
export let takeCond = predicate => gaze => {
    let next = Gaze.peek(gaze)
    match (next) {
        Some(value) when predicate(value) => {
            Gaze.next(gaze)
            Some(value)
        },
        _ => None
    }
}

/**
 * Create a Nibbler that accepts input based on a function that recieves the current token
 * and returns a bool.
 * 
 * @param predicate: The function used to decide if a token matches.
 * 
 * @returns A Nibbler that consumes input as long as the predicate passes.
 */
export let takeWhile = predicate => gaze => {
    let mut cont = true
    let mut results = []
    while (cont) {
        let next = Gaze.peek(gaze)
        match (next) {
            Some(value) when predicate(value) => {
                Gaze.next(gaze)
                results = List.append(results, [value])
            },
            _ => cont = false
        }
    }
    if (List.length(results) == 0) {
        None
    } else {
        Some(results)
    }
}

/**
 * Create a Nibbler that accepts input based on a function that recieves the current token 
 * with index starting at 0 and returns a bool.
 * 
 * @param predicate: The function used to decide if a token matches.
 * 
 * @returns A Nibbler that consumes input as long as the predicate passes.
 */
export let takeWhileIndex = predicate => gaze => {
    let mut index = 0
    let mut cont = true
    let mut results = []
    while (cont) {
        let next = Gaze.peek(gaze)
        match (next) {
            Some(value) when predicate(value, index) => {
                Gaze.next(gaze)
                results = List.append(results, [value])
                index += 1
            },
            _ => cont = false
        }
    }
    if (List.length(results) == 0) {
        None
    } else {
        Some(results)
    }
}

/**
 * Create a Nibbler that consumes input until the given Nibbler succeeds.
 * 
 * @param nibbler: The Nibbler used to test.
 * 
 * @returns The newly created Nibbler.
 */
export let takeUntil = nibbler => gaze => {
    let mut results = []
    let mut cont = true
    while (cont && !Gaze.isComplete(gaze)) {
        let res = Gaze.check(nibbler, gaze)
        match (res) {
            Some(_) => {
                cont = false
            },
            None => {
                let next = Gaze.next(gaze)
                results = List.append(results, [Option.unwrap(next)])
            }
        }
    }
    Some(results)
}

/**
 * Create a Nibbler that accepts a start
 * 
 * @param start: The starting token.
 * @param content: The Nibbler used to decide the matched content.
 * @param end: The ending token.
 * 
 * @returns A Nibbler that consumes a starting and ending token and returns the content that matches in between.
 */
export let between = (start, content, end) => gaze => {
    if (Gaze.next(gaze) == Some(start)) {
        match (Gaze.attempt(content, gaze)) {
            Some(result) => {
                if (Gaze.next(gaze) == Some(end)) {
                    Some(result)
                } else {
                    None
                }
            },
            None => None
        }
    } else {
        None
    }
}

/**
 * Creates a Nibbler that wraps another Nibbler and will never fail but will instead return an empty List.
 * 
 * @param nibbler: The Nibbler to wrap.
 * 
 * @returns The newly created Nibbler.
 */
export let optional = nibbler => gaze => {
    match (Gaze.attempt(nibbler, gaze)) {
        Some(res) => Some(res),
        None => Some([])
    }
}

export let repeat = nibbler => gaze => {
    let mut cont = true
    let mut results = []
    while (cont) {
        match (Gaze.attempt(nibbler, gaze)) {
            Some(result) => {
                results = List.append(results, [result])
            },
            None => cont = false
        }
    }
    if (results == []) {
        None
    } else {
        Some(results)
    }
}

/**
 * Create a Nibbler that accepts a List of Nibblers and only succeeds if all of the
 * passed in Nibblers succeed in order.
 * 
 * @param nibblers: A List of nibblers.
 * 
 * @returns A List of all of the results from each Nibbler internally grouped in Lists.
 */
export let takeAll = nibblers => gaze => {
    let mut results = []
    let mut nibblerIndex = 0
    while (nibblerIndex >= 0 && nibblerIndex < List.length(nibblers)) {
        let nibbler = Option.unwrap(List.nth(nibblerIndex, nibblers))
        match (Gaze.attempt(nibbler, gaze)) {
            Some(result) => {
                results = List.append(results, [result])
                nibblerIndex += 1
            },
            None => {
                nibblerIndex = -1
            }
        }
    }
    if (results == [] || nibblerIndex == -1) {
        None
    } else {
        Some(results)
    }
}

/**
 * Create a Nibbler that accepts a List of Nibblers and matches on the first that succeeds.
 * If all fail the created Nibbler will fail as well.
 * 
 * @param nibblers: A list of Nibblers to check.
 * 
 * @returns The newly created Nibbler.
 */
export let takeFirst = nibblers => gaze => {
    let mut result = None
    let mut nibblerIndex = 0
    while (nibblerIndex >= 0 && nibblerIndex < List.length(nibblers)) {
        let nibbler = Option.unwrap(List.nth(nibblerIndex, nibblers))
        match (Gaze.attempt(nibbler, gaze)) {
            Some(res) => {
                result = Some(res)
                nibblerIndex = -1
            },
            None => {
                nibblerIndex += 1
            }
        }
    }
    result
}
