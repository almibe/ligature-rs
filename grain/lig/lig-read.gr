// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

import Number from "number"
import Int64 from "int64"
import String from "string"
import Char from "char"
import Range from "range"
import Array from "array"
import { missing } from "../util/common"
import Nibblers from "../gaze/nibblers"
import Regex from "regex"
import { unwrap, isOk } from "result"
import Gaze from "../gaze/gaze"
import { identifier, Statement, LigatureError, error, String, Integer, Identifier } from "../ligature/ligature"

let charInRange = (char, start, end) => {
    let char = Char.code(char)
    let start = Char.code(start)
    let end = Char.code(end)
    char >= start && char <= end
}

let identifierPattern = unwrap(Regex.make("^[-a-zA-Z0-9._~:/?#\\[\\]@!$&'()*+,;%=]$"))

let identifierCharacterNibbler = Nibblers.takeWhile((c) => {
    Regex.isMatch(identifierPattern, toString(c))
})

export let identifierNibbler = Nibblers.between('<', identifierCharacterNibbler, '>')

//TODO the below Nibbler is incorrect
let stringContentNibbler = Nibblers.takeWhile((c) => Regex.isMatch(identifierPattern, toString(c)))

/**
 * A Nibbler that reads Strings as defined by lig.
 * TODO: this parser is incomplete and just used for testing currently.
 */
export let stringNibbler = Gaze.map(Nibblers.between('"', stringContentNibbler, '"'), s => {
    String.implode(Array.fromList(s))
})

let stringValueNibbler = Gaze.map(stringNibbler, s => String(s))

/**
 * A Nibbler that consumes an integer as defined by lig.
 * TODO: this doesn't handle negative numbers and maybe other cases like too small or large of a number
 */
export let integerNibbler = Gaze.map(Nibblers.takeWhile(c => charInRange(c, '0', '9')), i => {
    Int64.fromNumber(unwrap(Number.parse(String.implode(Array.fromList(i)))))
})

let integerValueNibbler = Gaze.map(integerNibbler, i => Integer(i))

let bytesNibbler = Nibblers.takeAll([
    Gaze.map(Nibblers.take('0'), (e) => [e]),
    Gaze.map(Nibblers.take('x'), (e) => [e]),
    Nibblers.takeWhile(c => charInRange(c, '0', '9') || charInRange(c, 'A', 'F'))
])

//TODO add bytes nibbler
export let valueNibbler = Nibblers.takeFirst([stringValueNibbler, integerValueNibbler])

export let whitespaceNibbler = Nibblers.takeWhile((c) => c == ' ' || c == '\t')

export let newLineNibbler = Nibblers.takeWhile((c) => c == '\n' || c == '\r')

/**
 * Reads an Identifier in lig format from a Gaze<Char>.
 * 
 * @param gaze: An instance of Gaze<Char>.
 * 
 * @returns An Identifier or Error.
 */
export let readIdentifier = gaze => {
    match (Gaze.attempt(identifierNibbler, gaze)) {
        None => error("Could not read Identifier.", None),
        Some(result) => {
            identifier(String.implode(Array.fromList(result)))
        }
    }
}

/**
 * Reads a Value in lig format from a Gaze<Char>.
 * This could be an Identifier, String, Byte Array, or Integer.
 * 
 * @param gaze: An instance of Gaze<Char>.
 * 
 * @returns A lig Value or an Error.
 */
export let readValue = gaze => {
    let id = readIdentifier(gaze)
    match (id) {
        Ok(i) => Ok(Identifier(i)),
        Err(_) => {
            match (Gaze.attempt(valueNibbler, gaze)) {
                None => error("Could not read Value.", None),
                Some(result) => {
                    Ok(result)
                }
            }
        }
    }
}

/**
 * Reads in a String and returns a List of Statements or an Error.
 * 
 * @param lig: The input String in lig format.
 * 
 * @returns A List of Statements or an Error.
 */
export let readLig = (lig: String) => {
    let gaze = Gaze.fromString(lig)
    let mut cont = true
    let mut statements = []

    //read opening white space
    Gaze.attempt(Nibblers.repeat(Nibblers.takeWhile(c => c == ' ' || c == '\t' || c == '\n' || c == '\r')), gaze)

    while (!Gaze.isComplete(gaze) && cont) {
        let entity = readIdentifier(gaze)
        Gaze.attempt(whitespaceNibbler, gaze)
        let attribute = readIdentifier(gaze)
        Gaze.attempt(whitespaceNibbler, gaze)
        let value = readValue(gaze)
        Gaze.attempt(Nibblers.repeat(Nibblers.takeWhile(c => c == ' ' || c == '\t' || c == '\n' || c == '\r')), gaze)
        if (isOk(entity) && isOk(attribute) && isOk(value)) {
            let statement: Statement = { entity: unwrap(entity), attribute: unwrap(attribute), value: unwrap(value) }
            statements = cons(statement, statements)
        }
    }

    if (cont) {
        Ok(statements)
    } else {
        Err("Could not read Lig.")
    }
}
