// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

import String from "string"
import Char from "char"
import Range from "range"
import Array from "array"
import { missing } from "../util/common"
import Nibblers from "../gaze/nibblers"
import Regex from "regex"
import { unwrap, isOk } from "result"
import Gaze from "../gaze/gaze"
import { identifier, Statement, LigatureError, error } from "../ligature/ligature"

let charInRange = (char, start, end) => {
    let char = Char.code(char)
    let start = Char.code(start)
    let end = Char.code(end)
    char <= start && char >= end
}

let identifierPattern = unwrap(Regex.make("^[-a-zA-Z0-9._~:/?#\\[\\]@!$&'()*+,;%=]$"))

let identifierCharacterNibbler = Nibblers.takeCond((c) => {
    Regex.isMatch(identifierPattern, toString(c))
})

export let identifierNibbler = Nibblers.between('<', identifierCharacterNibbler, '>')

export let whitespaceNibbler = Nibblers.takeCond((c) => c == ' ' || c == '\t')

export let newLineNibbler = Nibblers.takeCond((c) => c == '\n' || c == '\r')

/**
 * Reads an Identifier in lig format from a Gaze<Char>.
 * 
 * @param gaze: An instance of Gaze<Char>.
 * 
 * @returns An Identifier or Error.
 */
export let readIdentifier = gaze => {
    match (Gaze.attempt(identifierNibbler, gaze)) {
        None => error("Could not read Identifier.", None),
        Some(result) => {
            identifier(String.implode(Array.fromList(result)))
        }
    }
}

/**
 * Reads a Value in lig format from a Gaze<Char>.
 * This could be an Identifier, String, Byte Array, or Integer.
 * 
 * @param gaze: An instance of Gaze<Char>.
 * 
 * @returns A lig Value or an Error.
 */
export let readValue = gaze => {
    error("Not implemented.", None)
}

/**
 * Reads in a String and returns a List of Statements or an Error.
 * 
 * @param lig: The input String in lig format.
 * 
 * @returns A List of Statements or an Error.
 */
export let readLig = (lig: String) => {
    let gaze = Gaze.fromString(lig)
    let mut cont = true
    let mut statements = []

    //read opening white space
    Gaze.attempt(Nibblers.repeat(Nibblers.takeCond(c => c == ' ' || c == '\t' || c == '\n' || c == '\r')), gaze)

    while (!Gaze.isComplete(gaze) && cont) {
        let entity = readIdentifier(gaze)
        Gaze.attempt(whitespaceNibbler, gaze)
        let attribute = readIdentifier(gaze)
        Gaze.attempt(whitespaceNibbler, gaze)
        let value = readValue(gaze)
        Gaze.attempt(Nibblers.repeat(Nibblers.takeCond(c => c == ' ' || c == '\t' || c == '\n' || c == '\r')), gaze)
        if (isOk(entity) && isOk(attribute) && isOk(value)) {
            let statement: Statement = { entity: unwrap(entity), attribute: unwrap(attribute), value: unwrap(value) }
            statements = cons(statement, statements)
        }
    }

    if (cont) {
        Ok(statements)
    } else {
        Err("Could not read Lig.")
    }
}
